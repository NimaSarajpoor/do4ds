# SSL/HTTPS are the most basic network security tools  {#sec-ssl}

When you go to a website on the internet, you'll see the URL prefixed by
the `https` (though it's sometimes hidden by your browser because it's
assumed). `https` is actually a mashup that is short for `http` with
secure sockets layer (SSL).

These days, almost everyone actually uses the successor to SSL,
transport layer security (TLS). However, because the experience of
configuring TLS is identical to SSL, admins usually just talk about
configuring SSL even when they mean TLS.

These days, almost every bit of internet traffic is actually `https`
traffic. You will occasionally see `http` traffic inside private
networks where encryption might not be as important -- but more and more
organizations are requiring end-to-end use of SSL.

Securing your website or server using SSL/TLS is one of the most basic
things you can do to make sure your website traffic is safe. You should
always configure `https` -- full stop.

SSL/TLS security is accomplished by configuring your site or server to
use a SSL certificate (often abbreviated to cert). We'll go through the
details of how to get and configure an SSL certificate in this chapter
-- but first a little background on how SSL/TLS works.

### How SSL/TLS Enhances Security

SSL accomplishes two things for you -- identity validation and traffic
encryption.

When you go to a website, SSL/TLS is the technology that verifies that
you're actually reaching the website you think you're reaching. This
prevents something called a man-in-the-middle attack where a malicious
actor manages to get in between the server and the client of network
traffic. So, for example, you might think you're putting your bank login
information into your normal bank website, but there's a hacker sitting
in the middle, reading all of the traffic back and forth.

\[TODO: Image of man-in-the-middle\]

You can see this in action in your web browser. When you go to a website
protected by `https`, you'll see a little lock icon to the left of the
URL. That means that this website's SSL certificate matches the website
and therefore your computer can verify you're actually at the website
you mean to be at.

But how does your computer know what a valid SSL certificate is? Your
computer has a list of trusted Certificate Authorities (CAs) who create,
sell, and validate SSL/TLS certificates. So when you navigate to a
website, the website sends back a digital signature. Your computer
checks the signature against the indicated CA to verify that it was
issued to the site in question.

\[TODO: image of SSL validation\]

The second type of scary scenario SSL prevents is a snooping/sniffing
attack. Even if you're getting to the right place, your traffic travels
through many different channels along the way -- routers, network
switches, and more. This means that someone could theoretically look at
all your traffic along the way to its meaningful destination.

When your computer gets back the digital signature to verify the site's
identity, it also prompts an exchange of encryption keys. These keys are
used to encrypt traffic back and forth between you and the server so
anyone snooping on your message will just see garbled nonsense and not
your actual content. You can think of the SSL/TLS encryption as the
equivalent of writing a message on a note inside an envelope, rather
than on a postcard anyone could read along the way.

### Public and Private Certificates

In order to configure your site or server with SSL, there are three
steps you'll want to take: getting an SSL certificate, putting the
certificate on the server, and making sure the server *only* accepts
`https` traffic.

You can either buy an SSL certificate or make one yourself, using what's
called a *self-signed cert*.

There are a variety of places you can buy an SSL/TLS certificate, in
many cases, your domain name registrar can issue you one when you buy
your domain.

When you create or buy your cert, you'll have to choose the scope. A
basic SSL certificate covers just the domain itself, formally known as a
fully qualified domain name (FQDN). So if you get a basic SSL
certificate for `www.example.com`, `www.blog.example.com` will not be
covered. You can get a *wildcard certificate* that would cover every
subdomain of `*.example.com`.

<aside>

Note that basic SSL/TLS certification only validates that when you type
`example.com` in your browser, that you've gotten the real
`example.com`. It doesn't in any way validate who owns `example.com`,
whether they're reputable, or whether you should trust them.

There are higher levels of SSL certification that do validate that, for
example, the company that owns `google.com` is actually the company
Google.

</aside>

But sometimes it's not feasible to buy certificates. While a basic SSL
certificate for a single domain can cost \$10 per year or less, wildcard
certificates will all the bells and whistles can cost thousands per
year. This can get particularly expensive if you've got a lot of domains
for some reason.

Moreover, there are times when you *can't* buy a certificate. If you're
encrypting traffic inside a private network, you will need certificates
for hosts or IP addresses that are only valid inside the private
network, so there's no public CA to validate them.

There are two potential avenues to follow. In some cases, like inside a
private network, you want SSL/TLS for the encryption, but don't really
care about the identity validation part. In this case, it's usually
possible to skip that identity validation part and automatically trust
the certificate for encryption purposes.

It's also possible to create your own private CA, which would verify all
your SSL certificates. This is pretty common in large organizations. At
some point, every server and laptop needs to have the private CA added
to its set of trusted certificate validators.

A warning: it is deceptively easy to generate and configure a
self-signed SSL certificate. It's usually just a few lines of shell
commands to create a certificate, and adding the certificate to your
server or website is usually just a copy/paste affair.

However, it's pretty common to run into problems with self-signed certs
or private CAs. Making sure the certificate chain is correct, or running
into a piece of software that doesn't ignore the identity validation
piece right is pretty common. This shouldn't dissuade you from using
SSL/TLS. It's an essential, and basic, component of any security plan --
but using a self-signed cert probably isn't as easy as it seems.

When you configure your site or server, there will likely be an option
to redirect all `http` traffic to `https` traffic. If your server or
site is open to the internet, you should set this option.

## Comprehension Questions

1.  Write down the step-by-step procedure that is followed when you sit
    down at your laptop and type google.com into the search bar. Your
    explanation should include the following terms: URL, domain, DNS,
    protocol, HTTP, HTTPS, Default Address, Router
2.  Create a mind map of the following terms: Application Layer
    Protocol, HTTP, HTTPS, SSH, Port, 22, 80, 443
3.  In the following URLs, what are the domain, top-level domain, path,
    subdomain, query parameters?
    1.  https://blog.example.com/2022-10-30

    2.  facebook.com?search=alex.gold

    3.  https://alexkgold.space/mfy.html
4.  Write a mind map of the following terms: HTTP, HTTPS, SSL, TLS, CA,
    Public Certificate, Private Certificate, 443

## Lab: Configure SSL

There's a wonderful service called letsencrypt that is trying to make
the world more secure, acting as a free CA, and handing out free SSL
certificates to anyone who needs one.

They have a utility called certbot, which you just install on your
server and it can autogenerate an SSL certificate, install it on the
server, and even update your nginx configuration!

For anyone who's never dealt with self-signing certificates in the past,
let me tell you, this is magical!

    In our nginx configuration, we'll need to add a line certbot will use to know which site to generate the certificate for.

So inside the nginx configuration's server block, add

server_name do4ds-lab.shop www.do4ds-lab.shop;

substituting in your domain for mine. Make sure to do both the bare
domain and the `www` subdomain.

At that point, you can just install certbot and let it go! As of this
writing, that was as simple as running

sudo su apt-get install certbot apt-get install python3-certbot-nginx
systemctl restart nginx sudo certbot --nginx -d do4ds-lab.shop -d
www.do4ds-lab.shop

If you google "configure nginx with letsencrypt", there's a [great
article](https://www.nginx.com/blog/using-free-ssltls-certificates-from-lets-encrypt-with-nginx/)
by someone at Nginx walking you through the process if the commands
above change.

I'd recommend you take a moment and inspect the `/etc/nginx/nginx.conf`
file to look at what certbot added. You'll notice two things -- one is
inside the server block. You'll notice that the `listen 80` is gone.
We're no longer listening for `HTTP` traffic. Instead there's a
`listen 443` -- the default port for SSL, and a bunch of stuff that says
`# managed by Certbot` that tells nginx where to find the SSL
certificate.

Scrolling down a little, there's a new server block that is listening on
`80`. This block returns a `301`, which you might recall is a redirect
code (specifically for a *permanent* redirect) sending all `HTTP`
traffic to `HTTPS`.

Before we exit and test it out, let's do one more thing. RStudio does a
bunch of sending traffic back to itself. For that reason, the `/rstudio`
proxy location *also* needs to know to upgrade traffic from `HTTP` to
`HTTPS`.

So add the following line to the nginx config:

    proxy_set_header X-Forwarded-Proto https; #redirect URLs back to https

Proto here is short for *protocol*. So this is letting RStudio Server
know that when it forwards or redirects traffic, it should do so to
`HTTPS`, not `HTTP`.

------------------------------------------------------------------------

    Ok -- let's try out our newly-secured workbench!

Go to the URL your server is hosted at, and you'll find that...it's
broken again.

Before you read along, think for just a moment. Why is it broken? Maybe
scroll up to the image of the different layers of networking. Which one
still isn't open?

    If you thought of the AWS instance security group, you're right! You'll remember that by default it was open to SSH traffic on port `22`, and we opened it to `HTTP` traffic on `80`. But now that we're sending it `HTTPS` traffic on `443`, you'll have to open it to that traffic as well.

Add a rule to allow `HTTPS` traffic on 443 from anywhere.

NOW you should be able to go to `<your-domain>/rstudio` and get to
RStudio and `<your-domain>/jupyter` to get to JupyterHub! Voila!

    Note that you *also* can now SSH into `ssh test-user@<domain>`, so you don't ever need to remember IP Addresses for day-to-day operations.
